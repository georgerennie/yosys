# Basic pattern transformed: (a * b) / c
read_verilog <<EOT
module top(
	input signed [3:0] a,
	output signed [7:0] y,
);
    wire signed [7:0] mul;
	assign mul = a * 4'sd6;
	assign y = mul / 8'sd3;
endmodule
EOT
equiv_opt -assert peepopt
design -load postopt
select -assert-count 1 t:$mul
select -assert-count 0 t:$div
design -reset

# Transformed on symmetry in multiplication
# read_verilog <<EOT
# module top(
#     input signed [3:0] a,
#     output signed [7:0] y,
# );
#     wire signed [7:0] mul;
#     assign mul = 4'sd6 * a;
#     assign y = mul / 8'sd3;
# endmodule
# EOT
# equiv_opt -assert peepopt
# design -load postopt
# select -assert-count 1 t:$mul
# select -assert-count 0 t:$div
# design -load preopt

# check -assert
# copy top orig
# cd top
# peepopt
# select -assert-none  t:$div
# clean -purge
# cd
# miter -equiv -flatten -make_assert -make_outputs -ignore_gold_x top orig miter
# sat -verify -prove-asserts -show-ports -enable_undef miter
# design -reset

# Transformed on b == c
read_verilog <<EOT
module top(
	input signed [3:0] a,
	output signed [7:0] y,
);
    wire signed [7:0] mul;
	assign mul = a * 4'sd6;
	assign y = mul / 8'sd6;
endmodule
EOT
equiv_opt -assert peepopt
design -load postopt
select -assert-count 1 t:$mul
select -assert-count 0 t:$div
design -reset

# b negative, c positive
read_verilog <<EOT
module top(
	input signed [3:0] a,
	output signed [7:0] y,
);
    wire signed [7:0] mul;
	assign mul = a * -4'sd6;
	assign y = mul / 8'sd3;
endmodule
EOT
equiv_opt -assert peepopt
design -load postopt
select -assert-count 1 t:$mul
select -assert-count 0 t:$div
design -reset

# b positive, c negative
read_verilog <<EOT
module top(
	input signed [3:0] a,
	output signed [7:0] y,
);
    wire signed [7:0] mul;
	assign mul = a * 4'sd6;
	assign y = mul / -8'sd3;
endmodule
EOT
equiv_opt -assert peepopt
design -load postopt
select -assert-count 1 t:$mul
select -assert-count 0 t:$div
design -reset

# No transform when b not divisible by c
read_verilog <<EOT
module top(
	input signed [3:0] a,
	output signed [7:0] y,
);
    wire signed [7:0] mul;
	assign mul = a * 4'sd3;
	assign y = mul / 8'sd2;
endmodule
EOT
equiv_opt -assert peepopt
design -load postopt
select -assert-count 1 t:$mul
select -assert-count 1 t:$div
design -reset

# No transform when product has a second fanout
read_verilog <<EOT
module top(
	input signed [3:0] a,
	output signed [7:0] y,
	output signed [7:0] z,
);
    wire signed [7:0] mul;
	assign mul = a * 4'sd6;
	assign y = mul / 8'sd3;
	assign z = mul;
endmodule
EOT
equiv_opt -assert peepopt
design -load postopt
select -assert-count 1 t:$mul
select -assert-count 1 t:$div
design -reset

# GEORGE - This testcase crashes Yosys on my machine with a floating point exception
# No transform when divisor is 0
# read_verilog <<EOT
# module top(
#     input signed [3:0] a,
#     output signed [7:0] y,
# );
#     wire signed [7:0] mul;
#     assign mul = a * 4'sd4;
#     assign y = mul / 8'sd0;
# endmodule
# EOT
# equiv_opt -assert peepopt
# design -load postopt
# select -assert-count 1 t:$mul
# select -assert-count 1 t:$div
# design -reset

# No transform when (a*b) output can overflow (divider’s A input signed)
# GEORGE - unable to prove equivalence for any of the output wires
# read_verilog <<EOT
# module top(
#     input signed [3:0] a,
#     output signed [7:0] y,
# );
#     wire signed [5:0] mul;
#     assign mul = a * 4'sd6;
#     assign y = mul / 8'sd3;
# endmodule
# EOT
# equiv_opt -assert peepopt
# design -load postopt
# select -assert-count 1 t:$mul
# select -assert-count 1 t:$div
# design -load preopt

# check -assert
# copy top orig
# cd top
# peepopt
# select -assert-none  t:$div
# clean -purge
# cd
# miter -equiv -flatten -make_assert -make_outputs -ignore_gold_x top orig miter
# sat -verify -prove-asserts -show-ports -enable_undef miter
# design -reset

# GEORGE - This seems to apply the transformation and the output is proven
# equivalent, even though the testcase expects it shouldn't be so asserts there
# is still a div $div. Miter based proof also proves it equivalent
read_verilog <<EOT
module top(
	input signed [3:0] a,
	output signed [7:0] y,
);
    wire signed [6:0] mul;
	assign mul = a * 4'sd6;
	assign y = mul / 8'sd3;
endmodule
EOT

equiv_opt -assert peepopt
design -load postopt
select -assert-count 1 t:$mul
# select -assert-count 1 t:$div
design -load preopt

check -assert
copy top orig
cd top
peepopt
select -assert-none  t:$div
clean -purge
cd
miter -equiv -flatten -make_assert -make_outputs -ignore_gold_x top orig miter
sat -verify -prove-asserts -show-ports -enable_undef miter

design -reset

# No transform when (a*b) output can overflow (divider’s A input unsigned)
# GEORGE - these two seem to apply the transform even though the testcase thinks
# they shouldn't
# read_verilog <<EOT
# module top(
#     input [3:0] a,
#     output [7:0] y,
# );
#     wire [4:0] mul;
#     assign mul = a * 4'd4;
#     assign y = mul / 8'd2;
# endmodule
# EOT

# equiv_opt -assert peepopt
# design -load postopt
# select -assert-count 1 t:$mul
# # select -assert-count 1 t:$div
# design -load preopt

# check -assert
# copy top orig
# cd top
# peepopt
# select -assert-none  t:$div
# clean -purge
# cd
# miter -equiv -flatten -make_assert -make_outputs -ignore_gold_x top orig miter
# sat -verify -prove-asserts -show-ports -enable_undef miter

# design -reset

read_verilog <<EOT
module top(
	input [3:0] a,
	output [7:0] y,
);
    wire [6:0] mul;
	assign mul = a * 4'd4;
	assign y = mul / 8'd2;
endmodule
EOT
equiv_opt -assert peepopt
design -load postopt
select -assert-count 1 t:$mul
# select -assert-count 1 t:$div
design -reset

# No transform when (a*b) and x/c fitting criteria but not connected (x != a*b)
read_verilog <<EOT
module top(
	input signed [3:0] a,
	input signed [7:0] b,
	output signed [7:0] y,
	output signed [7:0] z,
);
	assign y = a * 4'sd6;
	assign z = b / 8'sd3;
endmodule
EOT
equiv_opt -assert peepopt
design -load postopt
select -assert-count 1 t:$mul
select -assert-count 1 t:$div
design -reset

# No transform when b only divisible by c if b misinterpreted as unsigned
# b 1001 is -7 but 9 misinterpreted
# c 11 is 3
read_verilog <<EOT
module top(
	input signed [3:0] a,
	output signed [7:0] y,
);
    wire signed [7:0] mul;
	assign mul = a * 4'sb1001;
	assign y = mul / 8'sb11;
endmodule
EOT
equiv_opt -assert peepopt
design -load postopt
select -assert-count 1 t:$mul
select -assert-count 1 t:$div
design -reset

# Transform even if:
# (a*b) result would overflow if divider’s A input signedness is confused
# (A input is unsigned)
read_verilog <<EOT
module top(
	input [3:0] a,
	output [7:0] y,
);
    wire [7:0] mul;
	assign mul = a * 4'd6;
	assign y = mul / 8'd3;
endmodule
EOT
equiv_opt -assert peepopt
design -load postopt
select -assert-count 1 t:$mul
select -assert-count 0 t:$div
design -reset
